# Indexes
Индексы

**План запроса**

**EXPLAIN** - Оператор EXPLAIN демонстрирует этапы выполнения запроса и может быть использован для оптимизации. По результату работы EXPLAIN можно выяснить, где в запросе узкие места, нужно ли использовать индексы, верный ли порядок и алгоритмы джойна выбраны при соединении таблиц и так далее.

**EXPLAIN** работает с SELECT, DELETE, INSERT, REPLACE и UPDATE операторами. В MySQL 8.0.19 и более поздних версиях он также работает с оператором TABLE. Оператор EXPLAIN выводит план запроса

При использовании оператора EXPLAIN можно указать формат вывода с помощью оператора FORMAT:
- TRADITIONAL — вывод в табличном формате;
- JSON — вывод в формате JSON;
- TREE — древовидный вывод с более точными описаниями обработки запросов, чем TRADITIONAL

**EXPLAIN ANALYZE** -  В MySQL 8.0.18 добавлена возможность использования оператора EXPLAIN ANALYZE, который запускает оператор и производит EXPLAIN вывод вместе с синхронизацией и дополнительной, основанной на итераторах, информацией о том, как ожидания оптимизатора совпадают с фактическим выполнением. EXPLAIN ANALYZE всегда использует TREE формат.

Для каждого итератора предоставляется следующая информация:
- ориентировочная стоимость исполнения,
- расчетное количество возвращаемых строк,
- фактическое время возврата первой строки в миллисекундах,
- фактическое время возврата всех строк в миллисекундах (при наличии нескольких циклов этот пункт показывает среднее время на цикл),
- количество строк, возвращаемых итератором,
- количество циклов

**Индексы**

**INDEX** – это инструмент, который позволяет оптимизировать выборку из базы данных, значительно сокращая время на получение данных

Без индекса MySQL должен начать с первой строки, а затем прочитать всю таблицу, чтобы найти соответствующие строки. Чем больше таблица, тем больше это стоит. Если таблица имеет индекс для рассматриваемых столбцов, MySQL может быстро определить позицию для поиска в середине файла данных, не просматривая все данные. Это намного быстрее, чем последовательное чтение каждой строки.

В MySQL **индексы** можно разделить на следующие **типы**:
- B-TREE — PRIMARY KEY, UNIQUE, INDEX и FULLTEXT,
- R-TREE — пространственные типы данных,
- INVERTED — в механизме хранения InnoDB для FULLTEXT,
- HASH — только в механизме хранения Memory.

**B-TREE** — древовидная структура данных, популярная для использования в индексах БД. Структура всегда отсортирована, что обеспечивает быстрый поиск точных совпадений (оператор равенства) и диапазонов (например, больше, меньше и операторов BETWEEN). Этот тип индекса доступен для большинства механизмов хранения, поскольку узлы B-TREE могут иметь много дочерних элементов. B-TREE не то же самое, что двоичное дерево, которое ограничено двумя дочерними элементами на узел

**R-дерево** (англ. R-trees) — древовидная структура данных (дерево), предложенная в 1984 году Антонином Гуттманом. Она подобна B-дереву, но используется для организации доступа к пространственным данным, то есть для индексации многомерной информации, такой, например, как географические данные с двумерными координатами (широтой и долготой).
Эта структура данных разбивает многомерное пространство на множество иерархически вложенных и, возможно, пересекающихся, прямоугольников (для двумерного пространства). В случае трехмерного или многомерного пространства это будут прямоугольные параллелепипеды (кубоиды) или параллелотопы.

**INVERTED - Инвертированный индекс** – это полнотекстовый индекс, структура данных, в которой для каждого слова коллекции документов в соответствующем списке перечислены все документы в коллекции, в которых оно встретилось.

**HASH-индексы** были предложены Артуром Фуллером, и предполагают хранение не самих значений, а их хэшей, благодаря чему уменьшается размер и увеличивается скорость обработки индексов из больших полей. Таким образом, при запросах с использованием HASH-индексов, сравниваться будут не искомое со значением поля, а хэш от искомого значения с хэшами полей. Из-за нелинейности хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий

**ADAPTIVE HASH** используется для оптимизации InnoDB таблиц, которые могут ускорить поиски с использованием строгого равенства и IN операторами, путем построения HASH-индекса в памяти. MySQL отслеживает поиск по индексу для InnoDB таблиц, и если запросы могут выиграть от HASH-индекса, он автоматически строит индекс для часто используемых страниц индекса. В некотором смысле ADAPTIVE HASH настраивает MySQL во время выполнения, чтобы использовать преимущества большой основной памяти, приближаясь к архитектуре баз данных с основной памятью. ADAPTIVE HASH всегда строится на основе существующего индекса B-TREE в таблице.

**Уникальные индексы** - Индексы разделяются на обычные и уникальные. Когда происходит поиск по обычному индексу, то есть по не уникальным значениям, то после первого нахождения соответствия поиск будет продолжен. В случае с уникальным индексом, после нахождения искомого значения поиск будет остановлен. Уникальные ключи работают так же, как и первичные ключи, только их может быть любое количество.

**Кластерные индексы** - Обычные индексы являются не кластерными, и сам индекс хранит только ссылки на записи таблицы. Когда происходит работа с индексом, определяется только список первичных ключей записей, подходящих под запрос. После этого происходит еще один запрос — для получения данных каждой записи из этого списка.
Кластерные индексы сохраняют данные записей целиком, а не ссылки на них. При работе с таким индексом не требуется дополнительной операции чтения данных. Первичные ключи таблиц InnoDB являются кластерными и выборки по ним происходят эффективно.

**Стоимость индексов**

При использовании индексов происходят дополнительные операции записи на жесткий диск. Таким образом при каждом обновлении или добавлении данных в таблицу, происходит также запись и обновление данных в индексе. Если в операциях SELECT индексы ускоряют работу, то в операциях INSERT и UPDATE время увеличивается, как и занимаемое место на жестком диске.
